<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="">
  <meta name="keywords" content="Partial Non-isometric Deformations with soft constrained Jacobian Fields">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PaNDAS</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-PYVRSFMDRL"></script> -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-PYVRSFMDRL');
  </script>

  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">
  <link rel="stylesheet" href="./static/css/bulma.min.css">
  <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="./static/css/index.css">
  <link rel="icon" href="./static/images/icon.svg">

  <!-- Three.js and loaders for advanced 3D viewer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://threejs.org/examples/js/loaders/PLYLoader.js"></script>
  <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://threejs.org/examples/js/loaders/STLLoader.js"></script>

  <style>
    /* Styles for 3D viewer container */
    #viewer {
      width: 100%;
      height: 600px;
      margin: 2rem 0;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      background: #f8f9fa;
    }

    /* Viewer controls styling */
    .viewer-controls {
      margin: 1rem 0;
      text-align: center;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
    }

    .viewer-controls button {
      padding: 0.5rem 1rem;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .viewer-controls button:hover {
      background: #f0f0f0;
      border-color: #999;
    }

    .viewer-controls button.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }

    .viewer-controls button.selection-mode {
      background: #28a745;
      color: white;
      border-color: #28a745;
    }

    .file-input-container {
      margin: 1rem 0;
      text-align: center;
    }

    .file-input-container input[type="file"] {
      margin: 0 0.5rem;
    }

    .file-input-container label {
      font-weight: bold;
      margin-right: 0.5rem;
    }

    /* Selection box styling */
    .selection-box {
      position: absolute;
      border: 2px dashed #ff0000;
      background: rgba(255, 0, 0, 0.1);
      pointer-events: none;
      display: none;
    }

    /* Mode indicator */
    .mode-indicator {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      z-index: 100;
    }

    /* Vertex count display */
    .vertex-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      z-index: 100;
    }

    body { margin: 0; overflow-x: hidden; }
    canvas { display: block; }

    .centered-title {
      text-align: center;
    }
  </style>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script defer src="./static/js/fontawesome.all.min.js"></script>
  <script src="./static/js/bulma-carousel.min.js"></script>
  <script src="./static/js/bulma-slider.min.js"></script>
  <script src="./static/js/index.js"></script>
</head>
<body>

<section class="hero">
  <div class="hero-body">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column has-text-centered">
          <h1 class="title is-1 publication-title">PaNDAS-JF: Partial Deformations with Adaptive Soft Constraints on Jacobian Fields</h1>
          <div class="is-size-5 publication-authors">
            <span class="author-block"><a href="https://tbesnier.github.io/">Thomas Besnier</a><sup>1</sup>,</span>
            <span class="author-block"><a href="https://daidedou.github.io/">Emery Pierson</a><sup>2</sup>,</span>
            <span class="author-block"><a href="https://dblp.org/pid/161/6737.html">Sylvain Arguillere</a><sup>3</sup>,</span>
            <span class="author-block"><a href="https://sites.google.com/view/mohameddaoudi">Mohamed Daoudi</a><sup>1,4</sup>.</span>
          </div>
          <div class="is-size-5 publication-authors">
            <span class="author-block"><sup>1</sup>Univ. Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France,</span>
            <span class="author-block"><sup>2</sup>LIX, Ecole Polytechnique, IP Paris, France,</span>
            <span class="author-block"><sup>3</sup>Univ. Lille, CNRS, UMR 8524 Laboratoire Paul Painlevé, Lille, F-59000, France,</span>
            <span class="author-block"><sup>4</sup>IMT Nord Europe, Institut Mines-Télécom, Centre for Digital Systems,</span>
          </div>
          <div class="column has-text-centered">
            <div class="publication-links">
              <span class="link-block">
                <a href="#" class="external-link button is-normal is-rounded is-dark">
                  <span class="icon"><i class="ai ai-arxiv"></i></span>
                  <span>arXiv</span>
                </a>
              </span>
              <span class="link-block">
                <a href="#" class="external-link button is-normal is-rounded is-dark">
                  <span class="icon"><i class="fab fa-github"></i></span>
                  <span>Code</span>
                </a>
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="section">
  <div class="columns is-centered has-text-centered">
    <div class="column is-four-fifths">
      <div class="content has-text-justified">
        <img src="#" alt="project_idea">
        <p><br>We present ...</p>
      </div>
    </div>
  </div>
</section>

<section class="section">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>...<br>...</p>
        </div>
      </div>
    </div>
    <br><br>
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3 centered-title">Proposed Method</h2>
        <div class="content has-text-justified">
          <img src="#" alt="architecture">
          <p><br>...</p>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="hero teaser">
  <div class="container is-max-desktop">
    <h2 class="title is-3 centered-title">Intro Video</h2>
    <div class="hero-body">
      <video id="teaser" controls playsinline height="100%">
        <source src="#" type="video/mp4">
      </video>
    </div>
  </div>
</section>

<section class="hero teaser">
  <div class="container is-max-desktop">
    <h2 class="title is-3 centered-title">Qualitative Examples</h2>
  </div>
</section>

<!-- Advanced 3D Mesh Viewer Section -->
<section class="section">
  <div class="container is-max-desktop">
    <h2 class="title is-3 centered-title">Interactive 3D Mesh Viewer with Vertex Selection</h2>

    <!-- File input for loading meshes -->
    <div class="file-input-container">
      <label for="mesh-file">Load 3D Mesh:</label>
      <input type="file" id="mesh-file" accept=".ply,.obj,.stl" />
      <small style="display: block; margin-top: 0.5rem; color: #666;">
        Supported formats: PLY, OBJ, STL
      </small>
    </div>

    <!-- 3D Viewer Container -->
    <div id="viewer">
      <div class="mode-indicator" id="mode-indicator">Navigation Mode</div>
      <div class="vertex-info" id="vertex-info">No mesh loaded</div>
      <div class="selection-box" id="selection-box"></div>
    </div>

    <!-- Viewer controls -->
    <div class="viewer-controls">
      <button id="toggle-mode-btn" onclick="toggleMode()">Switch to Selection Mode</button>
      <button onclick="resetCamera()">Reset View</button>
      <button onclick="toggleWireframe()">Toggle Wireframe</button>
      <button onclick="clearSelection()">Clear Selection</button>
      <button onclick="loadSampleMesh()">Load Sample Mesh</button>
    </div>

    <p class="has-text-centered">
      <small>
        <strong>Navigation Mode:</strong> Drag to rotate • Scroll to zoom • Right-click to pan<br>
        <strong>Selection Mode:</strong> Click and drag to box select vertices • Selected vertices turn red
      </small>
    </p>

    <!-- Features info -->
    <div class="content has-text-centered" style="margin-top: 2rem;">
      <p>
        <strong>Advanced Mesh Viewer Features:</strong><br>
        • Load local PLY, OBJ, STL files<br>
        • Box selection of vertices<br>
        • Real-time vertex coloring<br>
        • Wireframe visualization<br>
        • Smooth navigation controls
      </p>
    </div>
  </div>
</section>

<section class="section" id="BibTeX">
  <div class="container is-max-desktop content">
    <h2 class="title">BibTeX</h2>
    <pre><code>@inproceedings{name_of_project,
  title = {},
  author = {Besnier, T. and Pierson, E. and Arguillere, S. and Daoudi, M.},
  booktitle = {arXiv},
  year = {2024},
}</code></pre>
  </div>
</section>

<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <a class="icon-link" href="#"><i class="fas fa-file-pdf"></i></a>
      <a class="icon-link" href="#" class="external-link" disabled><i class="fab fa-github"></i></a>
    </div>
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content" style="text-align:center">
          <p>This website is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
          <p>Website source code based on the <a href="https://github.com/nerfies/nerfies.github.io">Nerfies</a> project page.</p>
        </div>
      </div>
    </div>
  </div>
</footer>

<!-- Advanced Mesh Viewer JavaScript -->
<script>
// Global variables for the 3D viewer
let scene, camera, renderer, controls;
let mesh, geometry, material;
let raycaster, mouse;
let isSelectionMode = false;
let isBoxSelecting = false;
let selectedVertices = new Set();
let originalColors = null;
let boxSelectStart = null;
let selectionBox = null;

// Initialize the 3D viewer
function initViewer() {
    const viewerContainer = document.getElementById('viewer');
    const width = viewerContainer.clientWidth;
    const height = viewerContainer.clientHeight;

    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    // Camera setup
    camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.set(5, 5, 5);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    viewerContainer.appendChild(renderer.domElement);

    // Controls setup
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Raycaster for selection
    raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.1;
    mouse = new THREE.Vector2();

    // Selection box element
    selectionBox = document.getElementById('selection-box');

    // Event listeners
    setupEventListeners();

    // Start animation loop
    animate();

    // Load a sample mesh by default
    loadSampleMesh();
}

function setupEventListeners() {
    const canvas = renderer.domElement;

    // File input
    document.getElementById('mesh-file').addEventListener('change', loadMeshFile);

    // Mouse events for selection
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);

    // Window resize
    window.addEventListener('resize', onWindowResize);
}

function loadMeshFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const extension = file.name.split('.').pop().toLowerCase();
        loadMeshFromData(e.target.result, extension);
    };

    if (file.name.endsWith('.ply') || file.name.endsWith('.stl')) {
        reader.readAsArrayBuffer(file);
    } else {
        reader.readAsText(file);
    }
}

function loadMeshFromData(data, extension) {
    let loader;

    // Clear existing mesh
    if (mesh) {
        scene.remove(mesh);
        selectedVertices.clear();
    }

    // Choose appropriate loader
    switch (extension) {
        case 'ply':
            loader = new THREE.PLYLoader();
            geometry = loader.parse(data);
            break;
        case 'obj':
            loader = new THREE.OBJLoader();
            const object = loader.parse(data);
            geometry = object.children[0].geometry;
            break;
        case 'stl':
            loader = new THREE.STLLoader();
            geometry = loader.parse(data);
            break;
        default:
            console.error('Unsupported file format');
            return;
    }

    // Process geometry
    geometry.computeVertexNormals();
    if (!geometry.attributes.color) {
        // Create color attribute if it doesn't exist
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        for (let i = 0; i < colors.length; i += 3) {
            colors[i] = 0.7;     // R
            colors[i + 1] = 0.7; // G
            colors[i + 2] = 0.7; // B
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    }

    // Store original colors
    originalColors = geometry.attributes.color.array.slice();

    // Create material and mesh
    material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide
    });

    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Center and scale mesh
    const box = new THREE.Box3().setFromObject(mesh);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    mesh.position.sub(center);
    mesh.scale.setScalar(5 / maxDim);

    // Update info
    updateVertexInfo();

    console.log('Mesh loaded successfully');
}

function loadSampleMesh() {
    // Create a sample sphere mesh for demonstration
    if (mesh) {
        scene.remove(mesh);
        selectedVertices.clear();
    }

    geometry = new THREE.SphereGeometry(2, 32, 32);

    // Add vertex colors
    const colors = new Float32Array(geometry.attributes.position.count * 3);
    for (let i = 0; i < colors.length; i += 3) {
        colors[i] = 0.7;     // R
        colors[i + 1] = 0.7; // G
        colors[i + 2] = 0.7; // B
    }
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Store original colors
    originalColors = colors.slice();

    material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide
    });

    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    updateVertexInfo();
}

function toggleMode() {
    isSelectionMode = !isSelectionMode;
    const btn = document.getElementById('toggle-mode-btn');
    const indicator = document.getElementById('mode-indicator');

    if (isSelectionMode) {
        btn.textContent = 'Switch to Navigation Mode';
        btn.classList.add('selection-mode');
        indicator.textContent = 'Selection Mode - Box Select Vertices';
        controls.enabled = false;
    } else {
        btn.textContent = 'Switch to Selection Mode';
        btn.classList.remove('selection-mode');
        indicator.textContent = 'Navigation Mode';
        controls.enabled = true;
        // Hide selection box
        selectionBox.style.display = 'none';
    }
}

function onMouseDown(event) {
    if (!isSelectionMode || !mesh) return;

    const rect = renderer.domElement.getBoundingClientRect();
    boxSelectStart = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };

    isBoxSelecting = true;
    selectionBox.style.display = 'block';
    selectionBox.style.left = boxSelectStart.x + 'px';
    selectionBox.style.top = boxSelectStart.y + 'px';
    selectionBox.style.width = '0px';
    selectionBox.style.height = '0px';
}

function onMouseMove(event) {
    if (!isSelectionMode || !isBoxSelecting || !boxSelectStart) return;

    const rect = renderer.domElement.getBoundingClientRect();
    const currentX = event.clientX - rect.left;
    const currentY = event.clientY - rect.top;

    const width = Math.abs(currentX - boxSelectStart.x);
    const height = Math.abs(currentY - boxSelectStart.y);
    const left = Math.min(currentX, boxSelectStart.x);
    const top = Math.min(currentY, boxSelectStart.y);

    selectionBox.style.left = left + 'px';
    selectionBox.style.top = top + 'px';
    selectionBox.style.width = width + 'px';
    selectionBox.style.height = height + 'px';
}

function onMouseUp(event) {
    if (!isSelectionMode || !isBoxSelecting || !mesh) return;

    const rect = renderer.domElement.getBoundingClientRect();
    const endX = event.clientX - rect.left;
    const endY = event.clientY - rect.top;

    // Perform box selection
    performBoxSelection(boxSelectStart.x, boxSelectStart.y, endX, endY);

    // Reset selection state
    isBoxSelecting = false;
    boxSelectStart = null;
    selectionBox.style.display = 'none';
}

function performBoxSelection(startX, startY, endX, endY) {
    const rect = renderer.domElement.getBoundingClientRect();
    const minX = Math.min(startX, endX);
    const maxX = Math.max(startX, endX);
    const minY = Math.min(startY, endY);
    const maxY = Math.max(startY, endY);

    // Convert to normalized coordinates
    const minNormX = (minX / rect.width) * 2 - 1;
    const maxNormX = (maxX / rect.width) * 2 - 1;
    const minNormY = -((maxY / rect.height) * 2 - 1);
    const maxNormY = -((minY / rect.height) * 2 - 1);

    // Check each vertex
    const positions = geometry.attributes.position;
    const colors = geometry.attributes.color;
    let newSelections = 0;

    for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3(
            positions.getX(i),
            positions.getY(i),
            positions.getZ(i)
        );

        // Transform to world coordinates
        vertex.applyMatrix4(mesh.matrixWorld);

        // Project to screen space
        const projected = vertex.project(camera);

        // Check if vertex is within selection box
        if (projected.x >= minNormX && projected.x <= maxNormX &&
            projected.y >= minNormY && projected.y <= maxNormY &&
            projected.z >= -1 && projected.z <= 1) {

            if (!selectedVertices.has(i)) {
                selectedVertices.add(i);
                // Color vertex red
                colors.setXYZ(i, 1, 0, 0);
                newSelections++;
            }
        }
    }

    if (newSelections > 0) {
        colors.needsUpdate = true;
        updateVertexInfo();
        console.log(`Selected ${newSelections} new vertices`);
    }
}

function clearSelection() {
    if (!mesh || selectedVertices.size === 0) return;

    const colors = geometry.attributes.color;

    // Restore original colors for selected vertices
    selectedVertices.forEach(index => {
        const i = index * 3;
        colors.array[i] = originalColors[i];       // R
        colors.array[i + 1] = originalColors[i + 1]; // G
        colors.array[i + 2] = originalColors[i + 2]; // B
    });

    selectedVertices.clear();
    colors.needsUpdate = true;
    updateVertexInfo();
}

function toggleWireframe() {
    if (!material) return;
    material.wireframe = !material.wireframe;
}

function resetCamera() {
    if (!mesh) return;

    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    camera.position.copy(center);
    camera.position.x += size.length();
    camera.position.y += size.length() * 0.5;
    camera.position.z += size.length();

    controls.target.copy(center);
    controls.update();
}

function updateVertexInfo() {
    const info = document.getElementById('vertex-info');
    if (!mesh) {
        info.textContent = 'No mesh loaded';
        return;
    }

    const totalVertices = geometry.attributes.position.count;
    const selectedCount = selectedVertices.size;
    info.textContent = `Vertices: ${totalVertices} | Selected: ${selectedCount}`;
}

function onWindowResize() {
    const viewerContainer = document.getElementById('viewer');
    const width = viewerContainer.clientWidth;
    const height = viewerContainer.clientHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Small delay to ensure Three.js is fully loaded
    setTimeout(initViewer, 100);
});
</script>

</body>
</html>