<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mesh Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        #controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #controls button:hover {
            background: #45a049;
        }
        #controls button.active {
            background: #f44336;
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #fff;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            display: none;
        }
        #info {
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <button id="toggleMode">Toggle Selection Mode</button>
            <button id="clearSelection">Clear Selection</button>
            <div id="info">
                <p>Rotate: Left Mouse + Drag</p>
                <p>Zoom: Mouse Wheel</p>
                <p>Selection Mode: OFF</p>
            </div>
        </div>
        <div id="selection-box"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Create sphere with vertex colors
        const geometry = new THREE.SphereGeometry(2, 32, 32);
        const material = new THREE.MeshPhongMaterial({
            vertexColors: true,
            side: THREE.DoubleSide
        });

        // Initialize vertex colors
        const colors = [];
        const color = new THREE.Color();
        for (let i = 0; i < geometry.attributes.position.count; i++) {
            color.setHSL(0.6, 0.5, 0.5); // Blue-ish color
            colors.push(color.r, color.g, color.b);
        }
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Add wireframe to see vertices better
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        sphere.add(wireframe);

        // Camera controls
        let isRotating = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let rotationX = 0, rotationY = 0;

        // Selection mode
        let selectionMode = false;
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };

        const toggleButton = document.getElementById('toggleMode');
        const clearButton = document.getElementById('clearSelection');
        const selectionBox = document.getElementById('selection-box');
        const infoText = document.querySelector('#info p:last-child');

        // Toggle selection mode
        toggleButton.addEventListener('click', () => {
            selectionMode = !selectionMode;
            toggleButton.classList.toggle('active');
            infoText.textContent = `Selection Mode: ${selectionMode ? 'ON' : 'OFF'}`;
        });

        // Clear selection
        clearButton.addEventListener('click', () => {
            const colorAttribute = geometry.attributes.color;
            const color = new THREE.Color();
            for (let i = 0; i < colorAttribute.count; i++) {
                color.setHSL(0.6, 0.5, 0.5);
                colorAttribute.setXYZ(i, color.r, color.g, color.b);
            }
            colorAttribute.needsUpdate = true;
        });

        // Mouse events
        document.addEventListener('mousedown', (e) => {
            if (selectionMode) {
                isSelecting = true;
                selectionStart.x = e.clientX;
                selectionStart.y = e.clientY;
                selectionEnd.x = e.clientX;
                selectionEnd.y = e.clientY;
                updateSelectionBox();
                selectionBox.style.display = 'block';
            } else {
                isRotating = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (selectionMode && isSelecting) {
                selectionEnd.x = e.clientX;
                selectionEnd.y = e.clientY;
                updateSelectionBox();
            } else if (isRotating) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;

                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;

                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (selectionMode && isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
                selectVertices();
            } else {
                isRotating = false;
            }
        });

        // Zoom with mouse wheel
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(10, camera.position.z));
        });

        // Update selection box
        function updateSelectionBox() {
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const width = Math.abs(selectionEnd.x - selectionStart.x);
            const height = Math.abs(selectionEnd.y - selectionStart.y);

            selectionBox.style.left = minX + 'px';
            selectionBox.style.top = minY + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        // Select vertices within box
        function selectVertices() {
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);

            const positions = geometry.attributes.position;
            const colorAttribute = geometry.attributes.color;
            const vector = new THREE.Vector3();

            for (let i = 0; i < positions.count; i++) {
                vector.fromBufferAttribute(positions, i);
                vector.applyMatrix4(sphere.matrixWorld);
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                    colorAttribute.setXYZ(i, 1, 0, 0); // Red color
                }
            }

            colorAttribute.needsUpdate = true;
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Smooth rotation
            rotationX += (targetRotationX - rotationX) * 0.1;
            rotationY += (targetRotationY - rotationY) * 0.1;

            sphere.rotation.x = rotationX;
            sphere.rotation.y = rotationY;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>